<html>
<mate charset="utf-8"/>
<title>sssss测试笔记TestNode</title>
<head>
<style>
*{padding:0;margin:0;}p{text-indent:14px;margin:3px;background:lightgreen;}h3{text-align:center;color:red;}span{color:red;font:bolder 16px/10px "宋体";}
</style>
</head>
<body>
<h3>软件测试笔记</h3>
<p><span>五大浏览器及生产厂商和内核:</span>1、IE(微软)--trident2、Chrome(谷歌)--blink3、Firefox(火狐)--gecko4、Safari(苹果)--webkit5、Opera(欧朋)--presto,现在已经使用blink</p>
<p><span>计算机特点</span>：1、计算机可以进行数学和逻辑运算。2、计算机可以对数据进行记忆和存储。3、计算机可以在程序的指令下自动高效的完成运算。</p>
<p><span>计算机组成</span>：1、硬件(组成计算机的那些物理设备。CPU、硬盘、内存、键盘、屏幕等) 2、软件：安装在计算机上的可以供客户使用的操作指令集合。</p>
<p><span>根据“冯诺依曼”理论将硬盘分为五个组成部分</span>：1、输入设备2、输出设备3、控制器和处理器(中央处理器CPU)4、存储设备(分为内存：内存条与外存：u盘、硬盘等)  内存分为：只读内存(ROM,是给操作系统用的)和随机内存(RAM，除了ROM外的内存)</p>
<p><span>程序运行原理:</span>双击运行和程序，程序中的指令和命令以及数据会被加载到内存中。然后CPU从内存中获取数据和指令。内存是靠电信号来运行存取的，速度快。</p>
<p><span>其它进制转为十进制</span>：1、先确定当前数字的位数，然后从右向左数，依次认为是低位到高位。2、记下每位数字所在的位数N。3、取出每位上的数字m，然后用这个m去乘以当前进制的N-1次方。4、将每位上的相乘结果进行相加，最后的和就是该数值所对应的十进制值。</p>
<p><span>十进制转为二进制</span>：1、用这个十进制的数字除以2，得到商和余数。2、判断商是否为0，如果不是0则用这个商除以2 。3、直到商为0时结束。将余数反向排列。就是二进制。</p>
<p><span>八进制或者十六进制转为二进制</span>：1、将每位上的数字转为二进制。八进制转为二进制要写成三位，十六进制转为二进制写成4位。最后进行一一对应就行了。0--000、1--001、2--010、3--011、4--100、5--101、6--110、7--111   0--0000、1--0001、2--0010、3--0011、4--0100、5--0101、6--0110、7--0111、8--1000、9--1001、A--1010、B--1011、C--1100、D--1101、E--1110、F--1111</p>
<p><span>计算机当中最小的单位</span>：比特(bit/位)，字节：(bytes)比bit大一些的单位。1B=8bit/位。</p>
<p>1B=8bit  1KB=1024B 1MB=1024KB 1汉字=3B（字节）</p>
<p><span>Dos命令1</span>：1、跳出当前操作：ctrl+c 2、time 显示当前计算机时间3、shutdown /s /t 1800 计算机将在1800秒关闭4、shutdown /a 取消关闭5、cls清屏6、ping www.baidu.com 会出现ip，在输入ip可以进入相应的网站。也可以检查当前网络是不是通的。7、ipconfig -all 显示当前计算机里所有网卡列出来。ip地址会随着地域变化而变化。北京和广州就不会一样。mac地址:就是特理地址。已经烧入只读内存里，不会随着地域变化而变化。</p>
<p><span>DOS命令2</span>: 1、盘符+：可以切换盘符，如c:到c盘。d:到d盘。2、cd 改变目录。cd ..返回上级目录 cd .当前目录3、dir 可以显示当前目录所有文件夹和文件。4、cd / 返回根目录。5、md 目录名 可以新建文件夹  md aa\bb\cc可以创建多层文件夹6、DOS命令不能直接创建文件，但是可以间接创建。如：echo "aaa"> a.html 这是创建一个a.html的文件里面内容为aaa6、rd 目录名 删除空目录 rd /s 目录名 删除非空目录7、del 文件名 删除文件 del 目录的话 则是删除这个目录下的所有文件和目录。8、copy 目录/文件名 重命名 如copy test/a.txt c:/aa/b.txt 是把test目录下的a.txt复制到当前文件夹下（c盘下aa目录下），并重命名为b.txt 9、移动 move a.html C:/test 把某目录下的a.html移动到C盘下的test目录。移动文件一定要进入到文件所在的目录下。 move a.html C:/test/b.html 表示把a.html移动到c盘下的test目录下，并改名为b.html</p>
<p><span>软件测试:</span>使用人工或者自动化的手段来运行或测量软件系统的过程，以检验软件系统是否满足规定的要求，并找出与预期结果之间的差异。</p>
<p>测试用例:<span>测试用例</span>是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或者核实是否满足某个特定需求。</p>
<p>用于证明某个功能已经实现，称作<span>正向测试用例</span>。  反映某个无法接受、反常或意外的条件或数据，用于论证只有在所需条件下才能满足该需求，这种用例称作<span>反向测试用例</span>。</p>
<p><span>设计测试用例的目的</span>：1.有效性2.可复用性3.易组织性4.可评估性5.可管理性。6、可以理清思路，避免遗漏。7、提高测试效率。8、跟进测试进度。9、跟进重复性工作。</p>
<p><span>测试的原则：</span>1、测试应该尽早介入。2、所有的测试都应追溯到用户需求。3、程序员应避免检查自己的程序。4、设计测试用例应考虑到合法的输入和不合法的输入以及各种边界条件和意外情况。5、二八原则，80%的错误很可能存在于20%的主要功能模块中。6、对错误结果要进行一个确认的过程。7、制定严格的测试计划。8、完全测试是不可能的，测试需要终止。9、妥善保存测试过程中的所有文档。</p>
<p><span>软件测试的分类：</span>A：按测试阶段分：单元测试( UT:unit test)、集成测试(IT:system ingertaion test)、系统测试(ST:system test)、验收测试(正式验收测试或者UAT(user acceptance test):由客户派出对业务熟悉的人员来使用该软件进行的测试。、Alpha:α测试:一种前期的用户测试，公司内部组织员工及部分客户，模拟实际操作环境下进行验收测试(内测)。、Beta:β测试:一种后期的用户测试，此时系统已经通过内部测试，大部分错误已经改正，即将正式发布。在一个或多个真实环境下发布版本，进行测试(公测)。)。<br/>B:按测试技术(测试对象)分：白盒测试、黑盒测试、灰盒测试。<br/>C:按测试对象是否运行分：动态测试、静态测试(文档检查、代码走查、界面检查)。<br/>D:按不同的测试手段分：手工测试、自动化测试。<br/>E:按测试包含的内容分：功能测试、界面测试、安全测试、兼容性测试、易用性测试、性能测试、压力测试、负载测试。<br/>F:其他测试：冒烟测试(也叫预发布测试，在真正测试之前，先对测试版本的主要功能进行测试(主干测试)，如果这些主要的功能都无法通过(测试阻塞)，或者存在很多Bug，就打回版本，不接着往下测试了。)、回归测试、探索性测试(依个人的经验)。</p>
<p><span>软件质量的六大特性:</span>1、功能性(软件需要满足用户显式或者隐式的功能)2、易用性(软件易于学习和上手使用)3、可靠性(指的是软件必需实现需求当中指明的具体功能)4、效率性(类似软件的性能)5、可维护性(要求软件具有将某个功能修复之后继续使用的能力)6、可移植性(当前软件可以从一个平台移植到另一个平台上使用的能力)。</p>
<p><span>软件测试的流程:</span>1、需求分析阶段:阅读需求，理解需求，主要是对业务进行学习，分析需求点，参与需求评审会议。<br/>2、测试计划阶段:主要任务是编写测试计划，参考软件规格说明书、项目总体计划。<br/>3、测试设计阶段:主要是编写测试用例。参考需求文档、概要设计、详细设计等文档。有不明确的地方要及时和开发和产品经理沟通。用例写完后进行用例评审。<br/>4、测试执行阶段:首先要搭建测试环境，然后进行冒烟测试，以判定当前版本是否可测，如果预测通过，正式进入系统测试，遇到问题提交bug到缺陷管理平台，并对bug进行回归测试及跟踪，直到被测软件达到测试需求要求，没有重大bug，测试结束。<br/>5、输出测试报告。并对整个测试过程中产生的一些文档进行整理归档，方便后续版本的使用。</p>
<p><span>软件开发模型:</span>A、<span>瀑布模型</span> 是线性模型(项目计划-需求分析-软件设计-开发-软件测试-集成维护)。<span>优点:</span>1、开发各个阶段比较清晰。2、强调早期计划及需求调查。3、适合需求稳定的产品开发。<span>缺点:</span>1、依赖于早期的需求调查，不适应需求的变化。2、单一流程不可逆。3、风险往往延至后期才显露，失去及早纠正的机会。4、问题在项目后期才开始暴露。5、前面未发现的错误会传递并扩散到后面的阶段，可能导致项目失败。<br/>B、<span>快速原型模</span>:实现一个基本原型，让用户对原型进行评价，逐步调整，使其满足用户最终需求。<span>优点</span>:适合不能确定需求的软件<span>缺点:</span>不适合开发大型系统</p>
<p><span>软件测试模型:</span>A:<span>V模型:</span>流程:需求分析-概要设计-详细设计-编码-单元测试-集成测试-系统测试-验收测试，形成一个V字，也是线性的一种。<span>优点:</span>1、测试V模型包含了底层测试(检验源代码质量的测试，如:单元测试)和高层测试(检验整个系统的需求:如:系统测试)2、V模型清晰的标识了软件开发的阶段。3、采用自上而下逐步求精的方式把整个开发过程分成不同的阶段，每个阶段的工作都很明确，因此便于控制开发过程。当所有的阶段都完成之后，该软件的开发过程也随之结束。<span>缺点:</span>1、V模型的自上而下的顺序，导致到了测试阶段，程序已经完成，错误已经产生，很多前期的错误一直到测试阶段才发现，甚至无法发现，往往无从修改了。2、同时在实际开发过程中，在需求阶段很难把客户的需求完全明确下来，因此当需求变更时将会导致阶段反复，而且都要重复需求分析、设计、编码、测试等过程，返工量非常大，灵活性比较低。<br/>B:<span>W模型，双V模型:</span>开发和测试同时进行，形成两个V。前面是开发括号里是测试。用户需求(验收测试设计)-需求分析(系统测试设计)-概要设计(集成测试设计)-详细设计(单元测试设计)-编码(单元测试)-集成(集成测试)-实施(系统测试)-交付(验收测试)。<span>优点:</span>1、测试伴随着整个开发周期，测试活动和软件开发同步进行。测试的对象不仅仅是程序，还包括需求文档、概要设计文档、详细设计文档。2、更早的介入测试，可以发现初期的缺陷，降低软件开发的成本。3、分阶段的工作，方便项目的整体管理。<span>缺点:</span>1、开发和测试依然是一种线性关系，下一阶段的工作依赖于上一阶段的工作完成。2、对于某些项目，如果没有文档，根本无法使用W模型。3、对于项目组人员的技术要求更高，实践起来会很困难。</p>
<p><span>一般正交表:</span>根据控件数和取值数选择一个合适的正交表，L下标nM的k次方，n代表行数，M代表每个控件的取值个数，k代表控件数。一般正交表适合当控件的取值数一致相等时。<span>使用步骤:</span>1、可以从网上找相对应的正交表。2、列举取值并编号，生成取值表。3、把取值表与选择的正交表进行映射(一一对应)，每一行就是一条测试用例。<br/><span>混合正交表:</span>存在一些控件的取值个数和其他不一致的时候用。<span>使用步骤:</span>1、制作取值表(不需要编号，列出数据即可)。2、复制表格中的数据放在新建的txt文本文档中，保存到allpairs文件夹中，如test.txt。3、Win+r cmd 使用控制台进入allpairs文件夹中:输入allpairs.exe test.txt>change.txt 回车。4、之后会在allpairs文件夹中生成change.txt生成测试用例。这个工具网上找。</p><p><span>测试用例设计方法选择:</span>1、如果测试的是功能和流程，可以使用场景法。2、需要输入数据的地方，要使用等价类划分法，同时要注意配合边界值法来做详细测试。3、如果有条件组合、条件之间相互影响的情况，可以使用因果图来制作出判定表。4、配置类软件，组合比较多，控件比较多的情况，可以使用正交表来测试。5、如果没有达到覆盖标准，就要增加一些测试用例。6、依靠直觉和经验追加一些测试用例(错误推测法)。</p><p><span>软件缺陷的分类:</span>A、致命错误:通常表为:程序无法跑通，系统无法运行，崩溃或者严重资源不足，应用模块无法启动或异常退出，主要功能模块无法使用。比如:1、由于程序所引起的死机，非法退出。2、死循环。3、数据库发生死锁。4、因错误操作引起的程序中断。5、功能错误。6、与数据库连接错误。7、数据通讯错误。B、严重错误:通常表现为:影响系统功能或操作，主要功能存在严重缺陷，但不影响系统稳定性。如:功能未实现。功能存在报错。数值存在轻微的计算错误。C:一般错误:通常表现为:界面、性能缺陷。如:边界条件下错误。容错性不好。大数据下容易无响应。大数据操作时，没有提供进度条。删除操作没有给提示。数据库表中有过多的空字段。D:提示问题:通常表现为:易用性及建议性问题:如:界面颜色搭配不好。文字排版不整齐。出现错别字。界面格式不规范。</p><p><span>缺陷分类:</span>1、系统缺陷:a、由于程序所引起的死机，异常退出。b、程序死循环。c、程序错误，不能执行正常工作或者重要功能，使系统崩溃或资源不足。2、数据缺陷:a、数据计算错误。b、数据约束错误。c、数据输入输出错误。3、数据库错误:a、数据库发生死锁。b、数据库表、缺省值未加约束条件。c、数据库连接错误。d、数据库表中存在过多的空字段。4、接口错误:a、数据通信错误。b、程序接口错误。5、功能错误:a、功能无法实现。b、功能实现错误。6、安全性缺陷:a、用户权限无法实现。b、超时限制错误。c、访问控制错误。d、加密错误。7、兼容性缺陷:与需求规定配置兼容性不符合。8、性能缺陷:a、未达到预期的性能指标。b、性能测试中出错，导致无法继续进行测试工作。9、界面缺陷:a、操作界面错误。b、打印内容、格式错误。c、删除操作未给出提示。d、长时间操作未给出提示。e、界面不规范。10、建议:a、功能建议。b、操作建议。</p>
<p><span>测试时定位元素:</span>1、可以用开发者工具。查看元素(f12)。可以在console里面写$x("//input[@class='search-input']")。找class为search-input的input。2、可以用火狐的-附加组件-获取xpath组件(如:try-xpath)。这样定位元素->//ul[@class='search-input']//a 代表ul下的a链接</p>
<p><span>接口测试流程:</span>需求分析->需求评审->场景设计->设计用例(功能、逻辑业务、异常(参数异常、数据异常)、安全、关键字)->数据准备->执行</p>
<p><span>linux之搜索命令locate:</span>语法:locate 文件名。locate locate 表示搜索和locate有关的文件。 locate是在/var/lib/mlocate这个后台数据库里面搜索，不需要遍历所有目录，搜索速度快耗费资源不大，但是只能搜索文件名。如里没有这个命令可以yum install mlocate 安装一下，安装好后要updatedb更新下才能使用，这个数据库大约一天更新一次，所以刚创建的文件要更新updatedb下才能马上看到。针对这个命令的配置是在/etc/updatedb.conf这个文件里。开启yes就是所有的配置生效，PRUNEFS 是代表不搜索的文件系统。PRUNENAMES是代表不搜索的文件类型。PRUNEPATHS是代表不搜索的路径。</p>
<p>linux中所有内容以文件形式保存，包括硬件  linux不是靠扩展名来区分文件类型的，是靠权限来区分  windows程序是不能在linux上直接安装和运行的，所以病毒和木马是不能在linux运行。</p>
<p>格式化并不是清空磁盘，是写入文件系统，对linux来说做了两件事，1.把整个分区分成等大小的数据块，默认4kb。2.在分区列表里建立二维表格，存放id，修改时间，权限，保存位置等等。</p>
<p><span>linux之搜索命令的命令whereis which:</span>1、whereis 命令 如:whereis ls 查看ls命令是在哪个目录下。-b只查找可执行文件 -m只查找帮助文档。2、which 命令名 查看命令的位置，有别名也会显示。whereis cd 和which cd 是查不到cd命令所在的位置的，因为cd命令是shell自带的命令，不是引进的外部命令。$PATH环境变量是定义的是系统命令的路径，把命令放在PATH定义的路径中，在执行命令时就不要如/bin/ls这样执行了，系统会在环境变量中找，ls就可以了。</p>
<p><span>linux之搜索命令find:</span>格式->find 搜索范围 搜索条件。1、搜索文件，find 目录路径 -iname 文件名，-i表示不区分大小写，find应该避免大范围搜索，会非常耗费资源。find不加通配符是完全匹配，加了是按照通配符规定的范围来匹配，*号是匹配任意内容如find /root -name "abc*"->表示在root下搜索全部以abc开始的文件，？号匹配任意一个字符，[]匹配任意一个中括号里的字符如find /root -name "*[ad]表示在root下搜索任意以a或者d结束的文件"。<br/>2、find 目录路径 -user root->表示搜索所有者为root的文件。find 目录路径 -nouser->表示搜索该路径下没有所有者的文件。正常是可以清除的，但是在/proc和/sys这两个目录下的没有所有者的文件是系统内核自动产生的，或者是外来数据，光盘，U盘等没有所有者的文件不要去删除。<br/>3、find 目录路径 -mtime(mmin)/ctiem/atime +10/-10/10 a代表文件访问时间，c代表文件改变时间，m代表文件修改时间。-10代表10天内，10代表10天当天，+10代表10天前。<br/>4、find 目录路径 -size 大小k用小写，M用大写，find 目录路径 -size +20k -a或者-o -size -50k 搜索目录下在20k到50k之间的文件，-a是两个条件都满足，-o是其中一个满足。<br/>5、find 目录路径 -inum 节点号->知道i节点查文件名。<br/>6、find 目录路径 -size +20k -a或者-o -size -50k -exec ls -lh {} \;表示查找出这些文件，再对结果执行显示详细信息的操作。rm -rf表示找到后直接删除。</p>
<p><span>linux之搜索命令grep:</span>grep [选项] 字符串 文件名->表示在文件中搜索字符串。-i不区分大小写，-v取反。配合正则来使用，grep '^$' 文件->表示在文件中找空行，开头和结尾连一起就是空行。\b表示分隔符单词边界，如grep '\bx\b' 文件->在文件中查找左右都是单词边界的x。</p>
<p><span>linux之帮助命令man和help:</span>1、man 命令->查看命令的帮助文档。要在这个文档里找东西的话，如-d 可以 /-d回车 通过n向下找，b向上找。man有1-9个帮助级别:1->查看命令的帮助，2->查看可被内核调用的函数的帮助，3->查看函数和函数库的帮助，4->查看特殊文件的帮助(主要是/dev目录下的文件)，5->查看配置文件的帮助，6->查看游戏的帮助，7->查看其它杂项的帮助，8->查看系统管理员可用命令的帮助，9->查看和内核相关文件的帮助。<br/>查看命令拥有哪个级别:man -f 命令或者whatis 命令 如:man 5 ifconfig 。man -k 命令或者apropos 命令->查看和命令相关的所有帮助，如：apropos passwd 查看和passwd有关的，只要包含passwd就找出来。<br/>2、命令 --help ->获取命令选项(参数)的帮助。<br/>3、help 命令 ->获取shell内部命令的帮助。如何确定是不是shell内部命令，可以whereis 命令 看一下是否有命令可执行文件，没有就是内部命令。shell是用linux中，实现用户和计算机交互的桥梁、接口，把用户语言转化成机器语言。4、info 命令 用来获取命令的详细信息。回车->进入子帮助页面(带有*号标记)、u->进入上层页面、n->进入下一个帮助小节、p->进入上一个帮助小节。</p>
<p><span>linux之压缩命令:</span>常见压缩格式: .zip、 .gz、 .bz2、 .tar.gz、 .tar.bz2<br/>1、zip压缩文件:zip 压缩文件名 原文件 、压缩目录:zip -r 压缩文件名 原目录  解压缩:unzip 压缩文件。<br/>2、.gz压缩文件:gzip 原文件->原文件会消失。｜ gzip -c 原文件 > 压缩文件->原文件保留。｜ gzip -r 目录 ->压缩目录下的所有子文件，但是不能压缩目录。| 解压缩:gzip -d 压缩文件或者gunzip 压缩文件。<br/>3、.bz2压缩:bzip2 原文件 也不保留原文件。| bzip2 -k 原文件->保留原文件。bzip2不能压缩目录。.bz2解压缩:bzip2 -d 压缩文件或者bunzip2 压缩文件。-k保留压缩文件。<br/>打包:tar -cvf 打包文件名 原文件 -c打包 -v显示过程 -f指定打包后的文件名。解包:tar -xvf 压缩包名 ->会保留打包文件。可以先打包再压缩，解决bzip2和gzip不能压缩目录的问题。但是比较麻烦。<br/>打包且压缩:tar -zcvf 压缩包名(.tar.gz格式) 原文件 -z压缩为.tar.gz的格式。 解压缩为包(.tar格式):tar -zxvf 压缩包名(.tar.gz格式)&nbsp;&nbsp;tar -jcvf 压缩包名(.tar.bz2格式) 原文件  解压:tar -jxvf 压缩包名(.tar格式)<br/>只查看压缩包里的内容，不解压->tar -ztvf 压缩包名(.tar.gz格式)</p>
<p><span>linu之挂载光盘(在home目录下操作):</span>1、放入光盘，在虚拟机上直接放入iso镜像文件。2、建立挂载点。(一般挂在/mnt目录下，如:mkdir /mnt/cdrom/)。3、挂载光盘mount -t iso9660 /dev/cdrom  /mnt/cdrom/或者mount -t iso9660 /dev/sr0 /mnt/cdrom/ ，因为ll /dev/cdrom/可以看出sr0是cdrom的软链接，所以有两种方式来写。-t iso9660也可以省略，因为系统默认知道光盘的文件系统是iso9660。<br/>光盘卸载(一定要退出当前目录才能卸载):umount 设备文件各或者挂载点 如:umount /dev/sr0或者/mnt/cdrom <br/>挂载U盘:查看U盘设备文件名->fdisk -l  挂载U盘:->mount -t vfat /dev/sdb1 /mnt/usb/</p>
<p><span>linux之用户登录查看命令:</span>1、查看登录用户信息:w 用户名&nbsp;输出:USER->登录的用户名、TTY->登录终端(有本地终端tty和远程终端)、FROM->从哪个ip地址登录、LOGIN@->登录时间、IDLE->用户闲置时间、JCPU->指的是和该终端连接的所有进程占用的时间。这个时间不包括过去的后台作业时间，但却包括当前正在运行的后台作业所占用的时间。、PCPU->是指当前进程所占用的时间、WHAT->当前正在运行的命令。第一行表示:当前系统时间、系统共登录多长时间、当前系统当中共登录两个用户、系统在1分钟、5分钟、15分钟之前的平均负载。<br/>who 用户名。这个w的简化版，只输出用户名、登录终端和ip。作用都是查看系统当中有哪些用户。</p>
<p><span>linux之last命令:</span>last 查看登录系统的用户信息。输出:用户名、登录终端、登录IP、登录时间、退出时间(在线时长)。last命令默认是读取/var/log/wtmp数据。但是这个文件不能用vi读取，只能用last读取，目的是防止人为修改。<br/>lastlog 查看所有用户最后一次登录时间。也是读取/var/log/wtmp里面的数据。</p>
<p><span>linux之重定向:</span>1、标准输出重定向:命令 > 文件->把命令的输出以覆盖的方式写入文件,想要以追加的方式:命令 >> 文件。2、标准错误输出重定向:错误命令 2>文件->以覆盖的方式把错误命令的输出写入文件，不想覆盖:错误命令 2>>文件。3、正确输出和错误输出同时保存:命令 > 文件 2>&1(或者:命令 &>文件 ，追加用>>)->以覆盖的方式把正确和错误的输出保存在同个文件中，不覆盖用>>。4、正确的输出保存到文件1，错误的保存到文件2中(常用):命令>>文件1 2>>文件2。5、把命令输出扔到黑洞:命令 &>/dev/null</p>
<p><span>linux输入重定向:</span>wc 回车 随便输入单词 ctrl+d 会统计单词数、字符数和行数。输入重定向:wc < 文件名->统计文件中的单词数、字符数和行数。-c字符数、-w单词数、-l行数。wc << 输入开始字符后回车，继续随便输入，最后以开始字符结束后回车。</p>
<p><span>linux之磁盘管理命令:</span>1、df 查看磁盘分区的使用情况。-l仅显示本地磁盘(默认)、-a显示所有文件系统的磁盘使用情况、-h以1024进制显示、-H以1000进制显示、-T显示磁盘分区类型、-t显示指定类型的文件系统的磁盘分区情况、-x不显示指定的文件系统。<br/>2、du 统计磁盘上的文件大小。-b以byte字节单位统计、-k以KB统计、-m以MB统计、-h以1024进制、-H以1000进制、-s指定统计目标。</p>
<p><span>linux中对新硬盘分区:MBR老式分区模式(缺点1、主分区不超过4个。2、单个分区的容量最大2TB):</span>1、fdisk(只适合MBR分区模式) -l查看分区信息。fdisk /dev/sda->使第一块(sda,sdb第二块)硬盘进入待命状态，然后m查看帮助列表信息。输入n进行添加分区，p主分区，e扩展分区，然后对分区指定编号(linux中1-4是预留给主分区和扩展分区的)，接下来指定分区的扇区的起始位置和结束位置(+3000M代表3000M 也可以+3G)。通过p可以查看已经添加的分区。扩展分区(一个硬盘上最多只有一个)默认是不能使用的，要在扩展分区里面添加逻辑分区才可以使用。设置好这些后，分区表的信息还未真正写入磁盘中，还要w下。删除分区d再输入分区号。</p>
<p><span>GPT分区模式步骤1-3:(最多支持128个主分区，单个分区容量可以达到18EB，1EB=1024PB,1PB=1024TB，1TB=1024GB):</span>parted(这分区工具既可以给硬盘做MBR分区，也可以GPT分区)。<br/>1、parted 启动分区工具，默认是系统第一块硬盘(切换硬盘:select /dev/sdc，help是帮助信息，)。<br/>
2、指定分区表类型。选择好硬盘后，要进行指定分区表的类型，mklabel gpt(msdos,是MBR分区的分区表类型，因为fdisk只能进行MBR分区，所以系统会默认采用msdos分区表类型，不需要手工指定)。输入print可以查看当前硬盘的分区详情，print all可以查看所有硬盘的分区详情，可以看分区表类型。<br/>
3、开始分区，最后quit就可以了。有两种分区模式(a、交互模式，以询问的方式。b、命令模式，一名话完成，输入参数就可以。)，交互方式:输入mkpart，询问要指定的分区名称(可以不指定，默认会为空)，然后询问指定分区的文件系统类型(可以默认，也可以指定，默认了后面还有方法修改)，然后询问分区的开始和结束(gpt分区的开始和结束是表示从第几MB开始第几MB结束，而fdisk的开始和结束是扇区数据块的编号，gpt分区的第一块分区不要从0开始，不然数据块不能对齐[4k对齐，对固态硬盘很重要])。命令模式:mkpart 分区名称 开始位置 结束位置。<br/>4、删除分区。rm 分区编号(print查看的编号)。gpt分区没有主分区、扩展分区、逻辑分区的概念，分区就是分区。gpt分区默认使用MB为单位，要修改单位，可以使用unit GB这种方法修改。<br/>
5、分区格式化(为分区指定文件系统类型):mkfs.文件系统类型 设备文件名如:mkfs.ext3 /dev/sda1或者mkfs -t 文件系统类型 设备文件名。注意:MBR分区的扩展分区是不能格式化的，只有主分区和逻辑分区才可以。gpt分区格式化后是不能通过fdisk -l查看各个分区的文件系统类型，要parted进去输入print才可以查看。<br/>
6、分好区和格式化后，分区要进行挂载才能使用(往里写东西)。建立挂载点(mkdir /mnt/imooc),mount /dev/设备文件名 /mnt/imoo(挂载点)。mount挂载的分区只是临时生效，每次重启就会失效。要进行开机自动挂载可以vi /etc/fstab 在最后加入/dev/sda1 /mnt/imooc ext3 defaults 0 0这样格式的数据就可以了。<br/>
7、为硬盘添加swap交换分步骤:a、建立一个普通的linux分区。b、修改分区类型的16进制编码。c、格式化交换分区。d、启用交换分区。ab->进入fdisk /dev/sdb(进入某块硬盘的分区状态)，p可以查看此硬盘的所有分区。选择一块分区(输入t 再输入分区编号，输入L查看编码列表，选择输入swap对应的编码)。w保存。c->格式化swap，mkswap /dev/sdb6(设备文件名)。d->启用，swapon /dev/sdb6,通过free可以查看swap的加载情况，  停止swapoff /dev/sdb6<br/>
8、使用mkfs.ext4默认参数格式化磁盘后，发现格式化时间特别长，并且格式化会占用磁盘很大的空间。究其原因，原来inode会占用磁盘空间，每个inode占用256b大小空间。默认情况下，mkfs2fs会为每16kb的磁盘空间分配一个inode，
格式化时系统根据磁盘大小，计算可以保存的文件个数，进而为inode保留空间。
所以格式化大容量磁盘，系统会分配过多inode，为inode预留过多空间，导致磁盘空间占用特别大。mkfs.ext4有参数-i，可以指定：多大磁盘空间分配一个inode 增大-i参数，从而减小inode总数，可以减小inode占用的磁盘空间，减少磁盘浪费。除了更改-i参加，也可以直接通过-T参数直接指定多大磁盘空间分配一个inode。largefile和largefile4对应的【多大磁盘空间分配一个inode】其实是在 /etc/mke2fs.conf 定义的。
largefile 类型就是 1M 一个 inode
largefile4 类型就是 4M 一个 inode</p>
<p><span>linux文件权限和目录权限的理解:</span>录下有个文件，文件里有内容。若用户对文件有读权限可以查看里面的内容,有执行仅限就可以运行这个文件，有写权限可以vi echo 修改里面的内容，但是不能删除这个文件。因为文件是属于目录的，对目录有写权限才能删除这个文件。对目录有执行权限就是可以进入这个目录，对目录有读权限可以查看目录里的内容，对目录有写权限可以在目录里创建/删除/移动/复制文件或者目录。文件的最高权限是执行权限，目录的最高权限是写权限。</p>
<p><span>linux文件和目录默认权限:</span>1、umask 可以查看umask值 如:0022，第一位影响特殊权限，后三位影响文件或者目录刚建立的默认权限。文件默认不能建立为执行文件，需要手工赋予，所以文件默认最大权限为666。文件默认权限换算:666换算为(rw-rw-rw-)-022(----w--w-)=rw-r--r--(644)。2、目录默认最大权限为777，换算和文件一样的。umask 0033可以临时改的。要永久改的话，要到/etc/profile 下改。普通用户的uid从500开始，root的uid为0。</p>
<p><span>linux之特殊权限ACL(access control list访问控制列表):</span>1、:目录或者文件默认就一生种权限，所有者权限，所属组权限和其他人权限，为了解决权限不够用的问题，可以使用acl权限。ext类型文件系统家族可以用dumpe2fs -h 设备文件名 查看分区是否开启ACL权限，-h仅显示超级块中的信息，而不显示磁盘块中的详细信息。centos7文件系统是xfs，不能这样查，默认开启ACL权限。可以用xfs_info 设备文件名或者xfs_growfs 设备文件名 ，来查看xfs文件系统信息。<br/>
2、如果不支持ACL权限，可临时开启:mount -o remount,acl 挂载点(如/)->重新挂载根分区，并挂载加入acl权限。永久开启:/etc/fstab里，在defaults加上,acl然后mount -o remount /重新挂载或者重启系统，使设置生效。dmesg | grep -i acl->查看系统是否开启acl<br/>
3、设置acl权限:setfacl 选项 目录或者文件名 -m设定acl权限，-x删除指定的acl权限、-b删除所有的acl权限、-d默认acl权限、-k删除默认acl权限、-R递归设定acl权限。如:setfacl -m u:tony:rx av表示给用户tony设置acl权限，给组设定改成g:组名:权限。<br/>获取acl权限:getfacl 目录或者文件名<br/>
4、当设置了acl权限时，会有一个mask权限，这是用来指定最大有效权限的。给用户赋予了acl权限，需要和mask权限相与才能得到用户的真正权限。如mask=rwx acl=r-x 真正用户权限是rx。修改mask权限:setfacl -m m:rwx 文件 <br/>删除acl权限:setfacl -x u:用户 文件 删除组用g:用户组<br/>删除文件所有acl权限:setfacl -b 文件<br/>
5、递归设置acl权限:setfacl -m u:tony:rx -R av/->把av下所有已经存在的文件和目录都赋予acl权限。<br/>默认acl权限:setfacl -m d:u:用户名:权限 目录名->如果目录设定了默认acl权限，那么目录中所有新建的文件或者目录都会继承父目录的acl权限。</p>
<p><span>linu之sudo权限:</span>1、把本来只能超级用户root执行的命令赋予普通用户执行，sudo的操作对象是系统命令。<br/>超级用户先要赋予权限，普通用户才能用。赋予权限:visudo->实际修改的是/etc/sudoers文件。格式: user1  ALL=(ALL)   /sbin/shutdown -r now表示让user1在任何被管理的主机上以任何身份执行关机命令，命令一定要是绝对路径。给用户组赋予也是类似。<br/>查看用户可用的sudo命令:sudo -l,普通用户执行sudo赋予的权限:sudo /sbin/shutdown -r now<br/>
2、sudo权限要谨慎使用:如:user1 ALL=(ALL)  /usr/sbin/useradd，然后再添加user1 ALL=(ALL)  /usr/bin/passwd [A-Za-z]*,  !/usr/bin/passwd "",  !/usr/bin/passwd root ->这样才不危险，不然可以改root的密码，因为默认赋予的是root身份。/bin/vi 也是一样，可以进入/etc/shadow改密码。</p>
<p>1、变量叠加：“$变量名”后跟其他变量值。或者${变量名}连上其他变量值。set可以查看系统中存在的变量，包括自己定义的。-u参数，在调用未声明的变量时会报错，默认无任何提示。<br/>
2、vim 可以开启和关闭颜色高亮，在底行模式输入syntax on/off可以临时开启或者关闭，在/etc/vimrc 设置可以永久生效。<br/>
3、正则表达式是用来匹配文件里面的内容，而通配符是用来匹配文件的，find  ./ -name "*.log" 在当前目录下查找.log结束的文件，一定要用引号括起来。</p>
<p><span>linux之查看分区文件系统类型:</span>1、df -T 只可以查看已经挂载的分区和文件系统类型。<br/>
2、fdisk -l 可以显示出所有挂载和未挂载的分区，但不显示文件系统类型<br/>3、parted -l 可以查看未挂载的文件系统类型，以及哪些分区尚未格式化<br/>4、lsblk -f 也可以查看未挂载的文件系统类型。<br/>5、file -s /dev/sda3 可以列出指定的设备文件名的文件系统。</p>
<p><span>linux之软件安装管理:</span>1、linux安装包有两种:源代码包和RPM包(在系统光盘中，挂载光盘->进入/mnt/cdrom/Packages)。2、RPM包命名规则:httpd(软件包名)-2.2.15(版本)-15(发布的次数).el6.centos(适合的linux平台).1.i686(适合的硬件平台).rpm(扩展名) ，若安装时，发现有依赖的库文件，可以去www.rpmfind.net找下依赖关系。用yum在线管理可以解决这个问题，自己会安装依赖的包。<br/>3、rpm安装命令:rpm -ivh 包全名 i->install、v->显示详细信息、h->显示进度。<br/>4、rpm升级:rpm -Uvh 全包名  rpm卸载:rpm -e 包名  --nodeps不检测依赖性。<br/>4、rpm查询是否安装:rpm -q 包名 查询所有已经安装的RPM包:rpm -qa<br/>5、查询软件包详细信息:rpm -qi 包名  查询未安装的包信息:rpm -qip 包全名->要在Packages目录下操作。<br/>6、查询rpm包中文件安装位置:rpm -ql(list) 包名 rpm -qlp 包全名->查询未安装包打算安装在哪里。rpm包一般的默认安装位置:/etc/->配置文件安装目录、/usr/bin/->可执行的命令安装目录、/usr/lib/->程序所使用的函数库保存位置、/usr/share/doc->基本的软件使用手册保存位置、/usr/share/man->帮助文件保存位置。<br/>7、查询系统文件属于哪个rpm:rpm -qf(file) 系统文件名<br/>8、查询软件包的依赖性:rpm -qR 包名 -p可查询未安装的包。不实用会把需要依赖的已经安装的列出来。<br/>9、校验指定rpm包不否被修改过:rpm -V(virify) 已安装的包名 验证内容中8个信息的具体内容如下:S->文件大小是否改变、M->文件的类型或文件的权限(rwx)是否改变、5->文件的MD5校验和是否改变(可以看成文件内容是否改变)、D->设备的主从代码是否改变、L->文件的路径是否改变、U->文件的属主(所有者是否改变)、G->文件的属组是否改变、T->文件的修改时间是否改变。文件类型:c->配置文件(config file)、d->变通文档(documentation)、g->这个文件不应该被rpm包包含(ghost file)、L->授权文件(license file)、r->描述文件(read me)<br/>10、rpm包中文件提取:rpm2cpio 包全名 | cpio -idv ./usr/bin/ls->表示把rpm包转换成cpio格式，然后通过cpio命令把文件中的usr/bin/ls提取到当前目录下。如:whereis ls 显示ls命令在/usr/bin/ls里，rpm -qf /usr/bin/ls查看ls命令属于哪个rpm包，把ls移走做成ls命令丢失的假象，然后在非/mnt/cdrom/Packages目录下(因为这是光盘挂载目录只读，不能写)进行操作rpm2cpio /mnt/cdrom/Packages/全包名 | cpio -idv ./usr/bin/ls ,最后把这个目录下的ls移动到/usr/bin/ls就可以用了。-i:copy-in模式，还原、-d:还原时自动新建目录、-v:显示还原过程。
<p><span>linux之yum在线安装:</span>1、yum源文件:/etc/yum.repos.d/CentOS-Base.repo [base]容器名称，一定要放在[]内、name容器说明，可以自己随便写、mirrorlist镜像立站点，这个 可以注释掉、baseurl我们的yum源服务器的地址，默认是centos官网的yum源服务器，是可以使用的，如果你觉得慢可以改成你喜欢的yum源地址、enabled此容器是否生效，如果不写成enable=1或者不写都是生效，等于0不生效、gpgcheck如果是1是指RPM的数字证书生效，0不生效、gpgkey数字证书的公钥文件保存位置，不用修改。<br/>2、若没有网络的情况下，可以自己搭建本地的光盘yum源，不会占用网络带宽，速度更快，效率更高。(本地源配置好后，可以yum clean all清除之前yum源的缓存，然后yum makecache生成新的yum源缓存)步骤:1、把/etc/yum.repos.d/CentOS-Base.peop改名，这样就不会生效。然后让/etc/yum.repos.d/CentOS-Media.repo生效，把baseurl第一行写成光盘挂载点/mnt/cdrom，后两行注释掉。然后可以用yum list来检查是否安装成功，作用是用来检测yum源里有哪些软件包可以安装。<br/>3、yum命令:yum list 查询所有可用的软件包列表 yum search 关键字->搜索服务器上所有和关键字相关的包。<br/>3、yum安装:yum -y install 包名 -y自动回答yes。只要包名，因为安装包已经在服务器上列出来了，会自动匹配。一定要安装gcc包，这是C语言编译器，用于源码包安装软件。<br/>
4、yum升级:yum -y update 包名 -y自动回答yes，在服务器领域正常不建议升级，会造成损失，除非大漏洞。yum -y update后面不加包表示升级所有linux程序，千万不要用。很可能造成系统崩溃不能用。<br/>
5、yum卸载:yum -y remove 包名 -y自动回答yes，服务器应该使用最小化安装，要用到什么程序安装什么，尽量做到不卸载。对于初学都者来说，不建议用yum卸载，因为yum卸载不会提示相关程序依赖性，如果把系统依赖的包卸载了，系统就崩溃不能用了。<br/>
6、yum软件组管理命令:yum grouplist 列出所有可用的软件组列表。yum groupinstall 软件组名->安装指定的软件组  yum groupremove 软件组名 LANG=en_US切换英文，LANG=zh_CN.utf8切换中文<br/>
7、centos7安装mysql:yum install -y mariadb-server  ,启动服务systemctl start mariadb.service，  初始化数据库配置mysql_secure_installation，默认访问/var/www/html,</p>
<p><span>linux之rpm包安装和源码包安装区别:</span>1、安装位置不一样，rpm包建议就默认安装，源码包建议安装在/usr/local/apache2。2、启动命令不一样:rpm: systemctl start/stop httpd.service 或者service httpd start/stop,rpm安装的apache的网页默认在/var/www/html 关闭防火墙:systemctl stop firewalld.service  禁止防火墙开机启动:systemctl disable firewalld.service,在工作中建议使用源码包apache效率更高，同时存在rpm包和源码包apache时，只能启动其中一个，不然会占用相同默认80端口。<br/>源码包保存位置:/usr/local/src,软件安装位置:/usr/local。<br/>3、源码包安装过程:1、下载源码包且解压缩，再进入解压缩目录(一定要进入)。2、./configure --prefix=/usr/local/apache2 3、make->编译，如果这步出错可以make clean 清除缓存和临时文件，回到编译前状态。4、最后make install 安装编译，成功会在/usr/local/apache2下产生很多目录。如果不成功，要make clean和把/usr/local/apache2下的文件删除重来。启动:/usr/local/apache2/bin/apachectl start 要删除直接删除整个安装目录，不会像windows一样残留垃圾文件。</p>
<p><span>linux之预定义变量:</span>1、$?->最后一次执行的命令的返回状态:echo $? 如果是0说明命令正确执行，非0表示不正确执行。<br/>2、$$->当前进程的进程号(PID)。ps aux->查询系统下所有正在运行的进程。<br/>find / -name hello.sh &->表示把这条执行命令放在后台执行。$!->表示后台运行的最后一个进程的进程号。</p>
<p><span>linux之接收键盘输入:</span>1、read 选项 变量名 -p表示输出提示信息、-t表示等待用户输入的时间，不加-t参数会一直等待、-n表示只接收指定的字符数就会执行、-s表示隐藏输入的数据。如：在一个脚本里写句脚本:read -p "please input your name:" -t 30 -s name表示输入的值会保存在变量name中。read -p "please input your sex [M/F]:" -n 1 sex->只接收一个字符就会执行。在脚本中要输出换行:echo -e "\n"</p>
<p><span>linux之sed命令，一行一行的读数据，读一行处理一行:</span>1、sed 选项 '动作' 文件名。-n:一般sed命令会把所有数据输出到屏幕上，加了-n sed命令会把经过处理的行输出到屏幕。-e允许对输入数据应用多条sed命令编辑，用分号隔开。-i用sed修改的结果直接修改原文件，而不是由屏幕输出。动作:a追加，在当前行后添加一行或者多行，$表示最后一行、c行替换，用c后面的字符串替换原数据行、i插入，在当前行前插入一行或者多行、d删除指定的行、p打印，输出指定的行、s字符串替换，用一个字符串替换另外一个字符串。格式为"行范围s/旧字符串/新字符串/g"。<br/>
sed '2p' 文件名->查看文件的第二行，没有加-n会把第二行输出，然后输出整个文件内容。<br/>sed '2,4d' 文件名->删除2-4行。sed '2a aabbccdd' 文件名->在第二行后面添加aabbccdd。<br/>
sed '4c aabbccdd' 文件名->替换第四行。、sed '/nologin/q' passwd 读到第一个nologin就结束sed<br/>
sed -i '3s/60/99/g' 文件名->把文件中的60改为99且直接修改保存原文件。sed -e 's/fengjie//g;s/furong//g' 文件名->同时把fengjie和furong替换为空，g全局替换，没有g只是替换匹配到的第一个。<br/>
2、2~3p->nl passwd | sed -n '2~3p'把passwd从2行开始每隔3行打印出来。<br/>
3、在文件中添加行，如果原文件有空格不是顶格的，要让新插入的行和文件的对齐，可以这样sed '$a \  test \n  test1，加空格使对齐，第一行因为添加a后面是以空格分隔的要加转义让后面加的空格生效。<br/>
4、进行多个sed动作:nl passwd | sed'{2,3d;s/false/true/g}'->删除2，3行再进行替换。<br/>
5、跳行输出:nl passwd | sed -n '{n;p}'->跳过一行打印一行，246...行。{p;n}->135...奇数行。n表示跳过当前行。<br/>
6、& 替换固定字符串:sed 's/^[a-z_-]\+/&123/' passwd->把用户名替换成用户名加123的形式。&代表原字符本身。 \u首字母大写，\l小写，\U整个字符串大写，\L整个字符串小写。sed 's/^[a-z_-]\+/\u&/' passwd->把用户名首字母改为大写。<br/>
7、分组提取信息，有几个小括号代表有几组(就是把匹配的内容用正则匹配一遍，要提取的加小括号):如提取ens33网卡ip->ifconfig ens33 | sed -n '2p' | sed 's/inet \([0-9.]\+\).*$/\1/' 、提取passwd中的前三个字段:sed 's/\(^[a-z_-]\+\):x:\([0-9]\+\):\([0-9]\+\).*$/\1 \2 \3/' passwd<br/>
8、r从源文件读内容放到目标文件指定行后面(不指定行每行后都会有)，不改变原文件:sed '1r 源文件' 目标文件、w把源文件(可以指定行，不指定是整个文件)内容写到目标文件中，会改变目标文件内容:sed '1w 目标文件' 源文件</p>
<p><span>linux之排序命令sort:</span>sort 选项 文件名，-f忽略大小写、-n以数值型排序，默认以字符串型排序、-r反向排序、-t指定分隔符，默认分隔符是tab。-k n[,m]按照指定的字段范围排序，从第n字段开始，m字段结束(默认到行尾)。sort -t ":" -k "3,3" /etc/passwd->以:号分割，从第三个字段开始排序，第三个字段结束排序，只用第三个字段排序。默认是以字符串型排序的，加-n可以设置为按照数值排序。</p>
<p><span>用户和用户组:</span>1、用户:使用操作系统的人。
用户组:具有相同操作权限的一组用户。/etc/group->存放所有的用户组。(组名称:x用户组密码点位符:组编号:组中用户列表[注意:当用户组中只有一个用户时且用户名和组名相同时，可以省略，所以用户列表为空不能肯定说是用户组中没有用户]，root用户组号一定是0，1-499是系统预留的组编号，一般是预留给安装在系统中的软件或者服务的，如安装了mysql软件就会自动创建一个mysql用户组，用户手动创建的用户组一般是从500开始的),/etc/gshadow组用户密码文件 /etc/passwd所有用户文件 /etc/shadow 用户密码文件。<br/>
2、添加用户组命令:groupadd 用户名 -g为用户组指定用户组编号。
修改用户组编号命令:groupmod -g 编号 用户组名 
添加用户同时指定用户组(添加的是主要组):useradd -g 组名 用户名，useradd -d /home/test imooc 创建用户的同时为其指定家目录
usermod -l 新用户名 旧用户名->用新用户替换旧用户，家目录还是旧的。
usermod -d /home/新用户名 新用户名->把新用户的家目录改为和当前用户同名的目录 。
在etc目录下创建个nologin目录，touch /etc/nologin可以禁止除root用户以外的用户登录。 
passwd -l 上锁 -u解锁 -d无密码
把用户添加到附加组:gpasswd -a 用户名 组名(一个用户可以同时属于多个组) -d移除附加组
如果用户想让自己的身份属于附加组可以临时切换(一定是在用户登录情况下用，root无意义):newgrp 附加组名 
同时添加主要组和附加组:useradd -g group1(主要组) -G group2(附加组),group3，....
添加组密码:gpasswd 组名
设置用户资料:chfn 用户名  finger 用户名 显示用户资料
groups 用户名->查看用户所在的所有组(主要组和附加组).<br/>
3、高压力高负载和服务器建议一周重启一次，低压力一个月，好让服务器状态归零。减少故障的出现。</p>
<p><span>vim知识点:</span>vim有几种常用模式，normal普通模式，编辑(插入)模式，可视化模式(v)，底行(命令)模式。ctrl+m有回车的作用。<br/>
1、i进入插入模式，在光标所在字母前插入内容。<br/>
a进入插入模式，在光标所在字母后插入内容。<br/>
o进入插入模式，在当前行的下行插入内容。<br/>
I进入插入模式，在当前行的最开头插入内容。<br/>
A进入插入模式，在当前行的最末尾插入内容。<br/>
O进入插入模式，在当前行的上行插入内容。<br/>
在命令行可以ctrl+a(home)快速移到开头，ctrl+e(end)快速移到结尾。ctrl+b后移，ctrl+f前移。<br/>
命令行和文件编辑里通用。输入错了可以ctrl+h删除前一个字符，ctrl+w删除前一个单词，ctrl+u删除当前行(光标要在最后)。<br/>
2、v进入可视化模式(visual)，这个模式一般用来块状选择文本，选择好后可以进行复制删除等操作。v可以一个一个字母选择，利用方向键也可进行选择。<br/>
V可以直接选择一行。<br/>
ctrl+v可以进行块状选择内容。<br/>
3、普通模式下按 :vs(vertical split) 可进行竖分屏，按 :sp(split)可以进行横分屏。可以用q退出分屏。<br/>
4、普通模式下按 :range s/替换前内容(原内容)/目标内容/g(c执行时要确认/n显示匹配的次数,目标内容不要写为空就可以)，%(1,6) s/替换前内容(原内容)/目标内容/g  可以进行全局替换。g表示全局，s表示替换。%表示全部替换。替换1,6行的内容。<br/>
5、插入模式切换到普通模式，esc按起来不方便，ctrl+c(可能会中断某些插件不建议用)，ctrl+[ 更好。<br/>
6、普通模式切换到插入模式，gi可以快速跳转到最后编辑的地方并切换到插入模式。<br/>
7、普通模式下，单个字符移动。按h进行左移，l右移，j下移，k上移。<br/>
8、行间快速搜索移动。普通模式下，f跟上搜索的字符(正向移动，搜索后面的，F跟上字符可反向搜索前面的字符)，会定位在该字符上，按;号移动到下一个，按,号移动到上一个。如fg。t跟上字符可以移动到该字符的前一个字符，T跟上字符，表示反向搜前面的字符，且光标定位在此字符后一个字符。如tw。<br/>
9、普通模式下，单词移动。w/W移动到下个单词开头，e/E移动到下个单词结尾。b/B移动到上个单词开头。小写的代表移动的单词是以非空白符分割的，大写的代表是以空白符分割的。<br/>
10、移动到一行的行首或者行尾。0移动到行首(可以是空白字符)，^号移动到行首(非空白字符)。$移动到行尾(可以是空白字符),g_移动到行尾(非空白字符)。<br/>
11、页面移动。gg移动到文件的最开头，G移动到文件结尾，ctrl+o可以退回到之前的位置。H/M/L跳转到屏幕的开头、中间、结尾。ctrl+u上翻页，ctrl+f下翻页，zz可以把当前行置为屏幕中间。<br/>
12、删除字符:x删除单个字符，dw(daw)可以删除单词,会删除单词周围空格，diw不会删除空格。dd删除一行。dt)可以删除当前字符到)之间的内容(to 到的意思)。d0可以删除到开头的位置，d$可以删除到结尾的位置。2dd可以删除两行，4x可以删除4个字符。可视化模式下也可以用d和x。<br/>
13、修改字符:r跟上字符可以快速进行字符替换，如rq，把光标上的字符替换成q。R跟上字符，会不断替换后面的字符。s表示删除当前光标上的字符并进入插入模式。S直接删除整行并进入插入模式。r和s也可以配合数字使用，如5rg把当前字符往后的5个字符替换成g，4s删除4个字符并进入插入模式。<br/>
14、修改字符:caw(cw)删除当前单词且包括空格并进入插入模式。ci"可以删除当前字符到"之间的内容进入插入模式，ca"会删除引号及之间的内容。C删除光标往后的整行并进入插入模式。ct某字符，会从光标字符删除到这个字符之间的内容并进入插入模式。<br/>
15、查找字符:/字符 。n可以跳转到上一个匹配，N跳转到下一个匹配。*可以进入当前单词的前向匹配，#可以进行当前单词后向匹配。<br/>
16、多文件编辑:有三个概念，buffer(缓冲区，打开一个文件时，会加载文件内容到缓冲区，为其分配内存。之后的修改都是针对缓冲区。只有保存后才写入文件)，window(窗口，是buffer可视化的分割区域),tab(可以组织窗口为一个工作区)。:ls可以查看当前有几个缓冲区，:e 文件名 可以再打开其他文件，:b n可以跳转到第n个缓冲区，:bpre :bnext :bfirst :blast或者用:b 文件名也可以跳转。<br/>
17、多文件编辑:使用:vs垂直分割窗口，:sp水平分割窗口，可以:vs 文件名 分割的时候打开。ctrl+w在窗口间来回切换，ctrl+w跟上hjkl可以切换到左下上右边窗口。两个窗口对换左右位置，先按ctrl+w,再按L把窗口换到右边，H左边。<br/>
18、多文件编辑:重排窗口:ctrl+w再=，使所有窗口等宽高，ctrl+w 再_或者|使窗口高度/宽度最大化。n跟上ctrl+w再_或者|,把活动窗口高度/宽度设为N行。<br/>
19、多文件编辑:标签页tab: 命令模式下:tabe 文件名->在新标签页edit中打开文件，ctrl+w跟上T把当前窗口移动到新的标签页，:tabc关闭close当前tab标签及其中所有窗口，:tabo保only留活动标签页，关闭其他标签页。:tabn切换下一标签gt(普通模式)也可以，:tabp上一标签gT。:tabn N 切换到第N个标签页Ngt。:tabnew 文件名 在新标签中打开。 <br/>
20、复制粘贴:y(yank)复制，p(put)粘贴，d(delete)剪。yy复制一行。 有时候复制的内容粘贴会错乱，要先:set paste 这样就不会了。设置了这个:set autoindent无效，要:set nopaste取消。<br/>
21、寄存器:vim中操作的是寄存器而不是系统剪贴板。使用d删除或者y复制时，默认内容都是放在无名寄存器中。<br/>
22、寄存器:"寄存器名称操作->把操作的内容放在寄存器中，没有指定默认到无名寄存器中。如:"ayiw复制一个单词到寄存器a中，"bdd删除当前行到寄存器b中。调用寄存器，普通模式下，按 "寄存器名称 操作。操作无名寄存器不需要手动调用。查看寄存器内容,命令模式下，:reg 寄存器名称 <br/>
23、寄存器:"0 是复制专用寄存器，在复制时会同时放到无名寄存器和0寄存器中。"% 当前文件名  ".上次插入的文本<br/>
24、寄存器:"+ 复制到系统剪贴板。:echo has('clipboard') 输出是1支持。 :set clipboard=unnamed 可以直接复制粘贴系统剪贴板内容。
25、宏完成批量操作:宏是一系列命令的集合，宏可以先录制再进行回放。普通模式使用q进行录制，q也可以停止录制。q{register},选择要保存的寄存器，把录制的命令保存其中，如qa。@{register}回放寄存器中存放的命令，如@a。<br/>
要给文本每行加引号，首先qa，I到行首加",A到行尾加"，按q退出录制。使用shift+v块选择。再:normal @a 回车。 也可以在第一行直接VG全选，:normal I"回车，:normal A"回车。<br/>
26、补全:a、单词补全：ctrl+n匹配，可进行向下移动，ctrl+p匹配可进行向上移动。&nbsp;b、文件名补全：ctrl+xf，按着ctrl加n向下翻，ctrl加p向上翻。&nbsp;c、filetype on开启文件类型，，set filetype然后回车可以显示文件类型。&nbsp;d、：r！echo%输出文件名，：r！echo %：p输出完整路径<br/>
27、配色：：colorscheme 显示当前配色。：colorscheme ctrl+d显示所有配色。：colorscheme 配色名更改配色<br/>
28、基本映射:normal模式下的映射，如 :map - x 用-可以删除字符，临时生效。visual可视模式下映射，:vmap \ U 把选中的文本转换大写。insert下映射，:imap <c-d> <Esc>ddi 插入模式下，ctrl+d 先进入normal模式再删除一行并进入插入模式。<br/>
29、任何时候都应该用非递归映射，nnoremap inoremap vnoremap 怕冲突。如 :nmap - dd 又:nmap \ -。<br/>
30、inoremap jj <Esc>`^ 可以保证在插入模式下按jj可以回到normal模式，`^并保持光标位置不变。 <br/>
31、为了避免冲突，可以先设置leader键，可以是 ，和空格，如 let mapleader=","   inoremap <leader>w <Esc>:w<cr><br/>
32、安装vim插件，前提安装git yum安装。先安装插件管理器https://github.com/junegunn/vim-plug  在终端输入命令安装curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim，然后把call plug#begin('~/.vim/plugged') 和call plug#end()写入.vimrc文件中，在这两行之间就可以放插件列表，如:https://github.com/mhinz/vim-startify 中的Plug 'mhinz/vim-startify'。soure ~/.vimrc让它生效，后:PlugInstall就可以了。<br/>
33、可以谷歌或者https://vimawesome.com去找插件。 修改vim的启动界面:https://github.com/mhinz/vim-startify ，状态栏美化：https://github.com/vim-airline/vim-airline，增加代码缩进线条：https://github.com/yggdroot/indentline	 <br/>
文档树：https://github.com/scrooloose/nerdtree   nnoremap <leader>v :NERDTreeFind<cr>->在文档树中找到当前文件的文件名，再按ctrl+w+p可以回去原来编辑位置，nnoremap <leader>g :NERDTreeToggle<cr>->展开文档树和关闭文档树，let NERDTrrShowHidden=1->显示隐藏文件,在启动vim时自动开启目录树: autocmd vimenter * NERDTree<br/>
快速查找文件并打开：https://github.com/ctrlpvim/ctrlp.vim 可以配合nerdtree使用。加入let g:ctrlp_map = '<c-p>'就可以了。<br/>
快速跳转到文件中任何一个字符:https://github.com/easymotion/vim-easymotion 设置映射 nmap tt <Plug>(easymotion-s2)，在文件中按下tt就可以输入想要查找的字符了。<br/>
成对增加、修改或者替换:https://github.com/tpope/vim-surround , 用ds可以删除成对的符号：如ds " ，用cs可以替换成对符号:cs " ' ，用ys可以增加成对符号:ys iw " <br/>
模糊搜索:https://github.com/junegunn/fzf.vim 把 Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' } Plug 'junegunn/fzf.vim'放到.vimrc中，:Files 路径 可以查看当前路径下所有文件，:Ag 字符串 可以想找字符串，ctrl+k上移，ctrl+j下移。Ag安装:下载 wget https://github.com/ggreer/the_silver_searcher/archive/master.zip ，安装需要的工具包： yum -y install pcre-devel xz-devel zlib-devel ， 解压代码，进入the_silver_searcher-master执行./build.sh进行编译，编译之后执行sudo -s make install 进行安装。不指定安装目录默认安装到/usr/local/bin下。<br/>
</p>
<p><span>jenkins自动化搭建测试环境、持续集成:</span>1、安装:到jenkins.io下载Generic java package。<br/>
2、启动:java -jar jenkins.war 若端口被占用 可以java -jar jenkins.war --httpPort=其他端口号。在本机输入localhost:端口号 进行登录。如果是linux要在windows上登录，linux ip：端口号。<br/>
3、可以选择默认安装插件，再自己安装Rebuilder和safe restart。<br/>
4、全局安全性配置: Configure GlobalSecurity-授权策略-安全矩阵,添加用户权限。<br/></p>
<p><span>应用服务器部署</span>:1、linux要做的准备:a、确定ip。b、确定用户名和密码。c、确定可以远程ssh连接。d、关闭防火墙。 netstat -anp|grep :22 查看ssh是否启动，启动ssh service sshd start ,关闭防火墙 service iptables stop(状态status)<br/>
2、安装java环境，yum -y install java<br/>
3、安装git，yum -y install git，并对git进行初始化:git config --global user.name "yang" git config --global user.emial "yang@abc.com" 名字和邮箱不一定要是真实的，在命令行中分别输入回车。生成授信证书:ssh-keygen -t rsa -C "yang@abc.com"。然后登录git把公钥配置到设置里的SSH and GPG keys。连接git服务器:ssh git@github.com<br/>
4、安装maven:到maven官网复制zip地址，wget安装解压。在/etc/profile 加入 export MAVEN_HOME=/root/apache-maven-3.6.1 export PATH=$MAVEN_HOME/bin:$PATH mvn -v检查<br/>
5、安装tomcat:官网复制zip地址，wget下载解压。进入tomcat目录，赋予所有人可执行权限 chmod a+x -R *  更改端口防止冲突 vim conf/server.xml 。启动tomcat: bin/startup.sh 检查：ps -ef|grep tomcat,浏览器输入linuxip:端口访问。<br/>
6、将linux主机注册到jenkins上:先新建节点，进入jenkins网页->jenkins管理->节点管理->新增节点，填写远程工作目录/root/.jenkins ,启动方式选ssh的 Non verifying Verification Strategy，主机写linuxip，添加用户名和密码后保存。点击节点名称就可以连接了。<br/>
7、新建一个任务:新建任务->选择自由风格 确定->高级 勾选限制项目的运行节点->构建->可执行shell。然后构建，在控制台查看输出。


</p>
</body>
</html>
